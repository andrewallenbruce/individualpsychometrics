{
  "hash": "287ae401a95e54a163daaf8e5c0c58e0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Matrices\nsubtitle: Introduction\ntoc-title: Matrices--Introduction\n---\n\n\n\n\n\n\n\nA matrix is a series of numbers arranged in rows and columns. We usually abbreviate matrices with a bolded uppercase letter:\n\n\n$$\n\\mathbf{A}_{j \\times k} =\n\\begin{bmatrix}\n  a_{1,1} & a_{1,2} & \\cdots & a_{1,k} \\\\\n  a_{2,1} & a_{2,2} & \\cdots & a_{2,k} \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  a_{j,1} & a_{j,2} & \\cdots & a_{j,k}\n\\end{bmatrix}\n$$\n\n\nFor example, \n\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n  1&2&3&4\\\\\n  5&6&7&8\\\\\n  9&10&11&12\n\\end{bmatrix}\n$$\n\nTo make a matrix in R, there are many possibilities. For the sake of simplicity, I will recommend using the `matrix` function with the `byrow` option set to `TRUE`. \n\nThe `matrix` function takes a vector and converts it to a matrix. By default, the `matrix` function assumes that the vector is a single column. For example,\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(1:4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n```\n\n\n:::\n:::\n\n\n\n\n\nBy setting the `nrow` (number of rows) or `ncol` (number of columns), the matrix dimensions are set. For example,\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(1:4, ncol = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n:::\n\n\n\n\n\nNote that the default is to fill in the matrix by columns. If you want it to fill by rows, set the `byrow` option to `TRUE`.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(1:4, ncol = 2, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n```\n\n\n:::\n:::\n\n\n\n\n\nIn general, creating matrices by row makes the code and the matrix look similar:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(c(3, 5, \n         2, 3),\n       nrow = 2,\n       byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    3    5\n[2,]    2    3\n```\n\n\n:::\n:::\n\n\n\n\n\nTo achieve the same matrix without the `byrow` option set to `TRUE` is possible, but the code will be the same order as the matrix:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(c(3, 2, \n         5, 3),\n       nrow = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    3    5\n[2,]    2    3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n::: {.callout-note title=\"You Try\"}\n\nMake vector `A` into a 2 by 2 matrix like so:\n\n$$\n\\mathbf{A}=\\begin{bmatrix}\n  2&3\\\\\n  5&7\n \\end{bmatrix}\n$$\n\n```{webr-r}\n#| label: ex-makeA\nA <- matrix(c(_,_,\n              _,_), \n            nrow = _, \n            byrow = _)\n\n```\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\n# Using the matrix function setting byrow = TRUE\nA <- matrix(c(2, 3,\n              5, 7),\n            nrow = 2,\n            byrow = TRUE)\n```\n\n\n\n</details>\n:::\n\n\n\n\n\n:::\n\n\n## Appending Matrices\n\n$$\n\\color{RoyalBlue}{\\mathbf{A}}=\\begin{bmatrix}\n\\color{RoyalBlue}{1} & \\color{RoyalBlue}{2} & \\color{RoyalBlue}{3} & \\color{RoyalBlue}{4} \\\\ \n\\color{RoyalBlue}{5} & \\color{RoyalBlue}{6} & \\color{RoyalBlue}{7} & \\color{RoyalBlue}{8} \\\\ \n\\color{RoyalBlue}{9} & \\color{RoyalBlue}{10} & \\color{RoyalBlue}{11} & \\color{RoyalBlue}{12}\n\\end{bmatrix}, \\color{Firebrick}{\\mathbf{B}}=\\begin{bmatrix}\n\\color{Firebrick}{13} & \\color{Firebrick}{14} & \\color{Firebrick}{15} & \\color{Firebrick}{16} \\\\ \n\\color{Firebrick}{17} & \\color{Firebrick}{18} & \\color{Firebrick}{19} & \\color{Firebrick}{20}\n\\end{bmatrix}\n$$\n\nThe equation below means, \"Make a new matrix called C by appending B to the bottom of A.\"\n\n$$\n\\mathbf{C}=\\begin{bmatrix}\n\\color{RoyalBlue}{\\mathbf{A}} \\\\ \\color{FireBrick}{\\mathbf{B}} \n\\end{bmatrix}=\n\\begin{bmatrix}\n\\color{RoyalBlue}{1} & \\color{RoyalBlue}{2} & \\color{RoyalBlue}{3} & \\color{RoyalBlue}{4} \\\\ \n\\color{RoyalBlue}{5} & \\color{RoyalBlue}{6} & \\color{RoyalBlue}{7} & \\color{RoyalBlue}{8} \\\\ \n\\color{RoyalBlue}{9} & \\color{RoyalBlue}{10} & \\color{RoyalBlue}{11} & \\color{RoyalBlue}{12}\\\\\n\\color{Firebrick}{13} & \\color{Firebrick}{14} & \\color{Firebrick}{15} & \\color{Firebrick}{16} \\\\ \n\\color{Firebrick}{17} & \\color{Firebrick}{18} & \\color{Firebrick}{19} & \\color{Firebrick}{20}\n\\end{bmatrix}\n$$\n\nIn R, adding new rows to a matrix is done with the `rbind` function (Think \"row bind\"). To append rows, matrices must have the same number of columns to be compatible.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\nB <- matrix(13:20, nrow = 2, byrow = TRUE)\nC <- rbind(A,B)\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n[5,]   17   18   19   20\n```\n\n\n:::\n:::\n\n\n\n\n\nThe `cbind` function (Think \"column bind\") works the same way but it appends columns to the right of a matrix. Matrices must have the same number of rows to be compatible.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:4, nrow = 2)\nB <- matrix(5:8, nrow = 2)\nC <- cbind(A,B)\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-note title=\"You Try\"}\n\nMake a 2 by 2 matrix **A**:\n\n$$\nA=\\begin{bmatrix}\n  11&13\\\\\n  17&19\n\\end{bmatrix}\n$$\n\nMake a 2 by 2 matrix `B`:\n\n$$\nB=\\begin{bmatrix}\n  11&13\\\\\n  17&19\n\\end{bmatrix}\n$$\n\n\nAppend `A` and `B` with `rbind` to make a 4 by 2 matrix like so:\n\n$$\n\\begin{bmatrix}\n  2&3\\\\\n  5&7\\\\\n  11&13\\\\\n  17&19\n\\end{bmatrix}\n$$\n\n\n```{webr-r}\n#| label: ex-rbinding\nA <- matrix(c(_,_,\n              _,_), \n            nrow = _, \n            byrow = _)\nB <- matrix(c(_,_,\n              _,_), \n            nrow = _, \n            byrow = _)\n\n# Now bind A and B by rows\nrbind(_,_)\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA <- matrix(c(2, 5, 3, 7), nrow = 2)\nB <- matrix(c(11,17,13,19), nrow = 2)\nrbind(A, B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    3\n[2,]    5    7\n[3,]   11   13\n[4,]   17   19\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\nNow use `cbind` to make a 2 by 4 matrix:\n\n$$\n\\begin{bmatrix}\n  2&3&11&13\\\\\n  5&7&17&19\n\\end{bmatrix}\n$$\n\n\n```{webr-r}\n#| label: ex-cbinding\n# Now bind A and B by columns\ncbind(_,_)\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\ncbind(A, B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    3   11   13\n[2,]    5    7   17   19\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n:::\n\n\n\n## Selecting parts of a matrix \n\nLet's make this matrix:\n\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n  1&2&3&4\\\\\n  5&6&7&8\\\\\n  9&10&11&12\n\\end{bmatrix}\n$$\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Select a single element of a matrix\n\nTo select a single element of a matrix, specify the row and column in brackets after the matrix. For example, the element $\\mathbf{A}_{3,2}$ (i.e., the 3^rd^ row and 2^nd^ column of $\\mathbf{A}$) is \n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[3,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-note title=\"You Try\"}\n\nSelect the element in row 2, column 3\n\n```{webr-r}\n#| label: ex-select\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\nA[_,_]\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[2,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n:::\n\n### Select a matrix row\n\nLeaving one of the slots in the bracket empty means that you want all of the elements in that row or column. \n\n$\\mathbf{A}_{1\\bullet}$ is the 1^st^ row of $\\mathbf{A}$.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n### Select a matrix column\n\n$\\mathbf{A}_{\\bullet 3}$ is the 3^rd^ column of $\\mathbf{A}$.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  7 11\n```\n\n\n:::\n:::\n\n\n\n\n\nBy default, whenever a single row, column, or element is returned from a matrix, R drops the row and column dimensions. If you wish to preserve the result in matrix form, set `drop` to `FALSE`:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[, 3, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    3\n[2,]    7\n[3,]   11\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nSelect column 1 of A.\n\n```{webr-r}\n#| label: ex-selectA1\nA\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 9\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n:::\n\n\n\n### Select several columns or rows\n\nA vector of integers will select whichever rows or columns you wish. Here are the 2^nd^ and 3^rd^ rows:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[2:3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    5    6    7    8\n[2,]    9   10   11   12\n```\n\n\n:::\n:::\n\n\n\n\n\nHere are the 1^st^ and 4^th^ columns:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[, c(1, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    5    8\n[3,]    9   12\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nSelect columns 1 and 3 of A. \n\n```{webr-r}\n#| label: ex-matrixcols\nA\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[, c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    5    7\n[3,]    9   11\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n:::\n\n\n### Selecting with Boolean vectors\n\nHere is the first two rows of $\\mathbf{A}$:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[c(TRUE,TRUE,FALSE),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n```\n\n\n:::\n:::\n\n\n\n\n\nThis seems like a strange way to do this but it is actually quite powerful. Any vector of `TRUE` and `FALSE` values can be used to select things. For example, select a column only if its first value is greater than 2:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\ns <- A[1,] > 2 # Creates a vector that tests whether the first row elements are greater than 2\nA[,s] # Select only the columns whose first value is greater than 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    3    4\n[2,]    7    8\n[3,]   11   12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nUse a Boolean vector to select columns that begin with 2. The operator for \"is equal to\" is `==`.\n\n```{webr-r}\n#| label: ex-boolean\ns <- A[] == _ \nA[,s] \n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\ns <- A[1,] == 2 \n# When only one column or row is selected, R returns a vector\nA[,s]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  6 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# To force R to return a matrix, set drop = FALSE\nA[,s, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    2\n[2,]    6\n[3,]   10\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n:::\n\n\n### Selecting with name vectors\n\nWe can give row and column names to a matrix like so:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nrownames(A) <- c(\"Gold\",\"Silver\",\"Bronze\")\ncolnames(A) <- c(\"Vault\",\"Uneven Bars\",\"Balance Beam\",\"Floor\")\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold       1           2            3     4\nSilver     5           6            7     8\nBronze     9          10           11    12\n```\n\n\n:::\n:::\n\n\n\n\n\nNow we can select rows and columns by names:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[c(\"Gold\",\"Bronze\"),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold       1           2            3     4\nBronze     9          10           11    12\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nUse the column names to select the Uneven Bars column\n\n```{webr-r}\n#| label: ex-uneven\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\nrownames(A) <- c(\"Gold\",\"Silver\",\"Bronze\")\ncolnames(A) <- c(\"Vault\",\"Uneven Bars\",\"Balance Beam\",\"Floor\")\n# select the Uneven Bars column\nA\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[,\"Uneven Bars\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Gold Silver Bronze \n     2      6     10 \n```\n\n\n:::\n\n```{.r .cell-code}\n# or to force returning a matrix\nA[,\"Uneven Bars\", drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Uneven Bars\nGold             2\nSilver           6\nBronze          10\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\nSelect the intersection of Silver and Floor\n\n```{webr-r}\n#| label: ex-silverfloor\nA\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[\"Silver\", \"Floor\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# or\nA[\"Silver\", \"Floor\", drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Floor\nSilver     8\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n:::\n\n## Replace portions of a matrix\n\nAny portion of a matrix can be replaced with new values. For example, this will replace the first row with zeros:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[1, ] <- c(0, 0, 0, 0)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold       0           0            0     0\nSilver     5           6            7     8\nBronze     9          10           11    12\n```\n\n\n:::\n:::\n\n\n\n\n\nThis can be done by column or row name as well\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[\"Gold\", ] <- c(0, 0, 0, 0)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold       0           0            0     0\nSilver     5           6            7     8\nBronze     9          10           11    12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nReplace the Vault column of $\\mathbf{A}$ with a vector of $\\{10,20,30\\}$\n\n```{webr-r}\n#| label: ex-replacevault\nA\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[, \"Vault\"] <- c(10, 20, 30)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold      10           0            0     0\nSilver    20           6            7     8\nBronze    30          10           11    12\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n:::\n\n## Transposing matrices\n\n[To *transpose* a matrix is to write its rows as columns and its columns as rows.]{.defword .column-margin}\n\nTo [transpose]{.defword} a matrix is to flip its rows into columns.\n\n$\\mathbf{A}'$ is matrix $\\mathbf{A}$ transposed.\n\nIf\n\n$$\\mathbf{A}=\\begin{bmatrix}\n1&2&3\\\\\n4&5&6\n\\end{bmatrix}$$\n\nThen \n\n$$\\mathbf{A}'=\\begin{bmatrix}\n1&4\\\\\n2&5\\\\\n3&6\n\\end{bmatrix}$$\n\n### Transposing in R\n\nIn R the `t` function transposes matrices.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:6, nrow = 2, byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n\n```{.r .cell-code}\nAprime <- t(A)\nAprime\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\n1. Make a 2 $\\times$ 5 matrix `A` of even numbers up to 20. \n2. Transpose `A`, assigning it to a variable called `Aprime`.\n3. Replace the last row (row 5) of `Aprime` with zeroes.\n\n```{webr-r}\n#| label: ex-even20transpose\nA <- matrix(seq(_,_,_), nrow = _)\n```\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA <- matrix(seq(2, 20, 2), nrow = 2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    2    6   10   14   18\n[2,]    4    8   12   16   20\n```\n\n\n:::\n\n```{.r .cell-code}\nAprime <- t(A)\nAprime\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    4\n[2,]    6    8\n[3,]   10   12\n[4,]   14   16\n[5,]   18   20\n```\n\n\n:::\n\n```{.r .cell-code}\nAprime[5, ] <- c(0, 0)\nAprime\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    4\n[2,]    6    8\n[3,]   10   12\n[4,]   14   16\n[5,]    0    0\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n:::\n\n\n\n## Square matrices\n\nIn a **square matrix**, the number of rows is equal to the number of columns.\n\n## Symmetric matrices\n\nA **symmetric matrix** is a square matrix that is equal to its transpose.\n\n$$\\mathbf{A}=\\mathbf{A}'$$\n\nThis means that for all elements, $a_{ij}=a_{ji}$.\n\nHere is an example of a symmetric matrix:\n\n$$\\begin{bmatrix}\n\\color{green}a & \\color{Firebrick}b & \\color{RoyalBlue}c\\\\\n\\color{Firebrick}b & \\color{gold}d & \\color{DarkOrchid}e\\\\\n\\color{RoyalBlue}c & \\color{DarkOrchid}e & \\color{orange}f\n\\end{bmatrix}$$\n\nTo verify that a matrix is symmetric in R:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nall(A == t(A))\n# Or use a dedicated function\nisSymmetric(A)\n```\n:::\n\n\n\n\n\nCorrelation matrices and covariance matrices are always symmetric.\n\n## Diagonal matrices\n\nA **diagonal matrix** is a square matrix consisting of zeroes everywhere except the diagonal. For example,\n\n$$\n\\mathbf{A} = \\begin{bmatrix}\na & 0 & 0\\\\\n0 & b & 0\\\\\n0 & 0 & c\n\\end{bmatrix}\n$$\n\nTo create a diagonal matrix, specify the diagonal vector and then insert it into the `diag` function like so:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\na <- 1:4\nA <- diag(a)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    2    0    0\n[3,]    0    0    3    0\n[4,]    0    0    0    4\n```\n\n\n:::\n:::\n\n\n\n\n\nAs we will see later, the `diag` function actually has several different purposes:\n\n1. It creates a diagonal matrix $\\mathbf{A}$ from a vector $\\mathbf{a}$.  \n    `A <- diag(a)` \n2. It extracts a diagonal vector $\\mathbf{a}$ from a matrix $\\mathbf{A}$. \n    `a <- diag(A)`\n3. It creates an identity matrix $\\mathbf{I}$ from a positive integer $n$.  \n    `I <- diag(n)`\n4. It replaces the diagonal of matrix $\\mathbf{A}$ with a new vector $\\mathbf{b}$.  \n    `diag(A) <- b`\n\n## Adding Matrices\n\nIn order to add matrices, they must be *compatible*, meaning that they must have same number of rows and columns.\n\nTo add compatible matrices, simply add elements in the same position.\n$$\n\\begin{aligned}\\mathbf{A}+\\mathbf{B}&=\n\\begin{bmatrix}\na_{11} & a_{12}\\\\\na_{21} & a_{22}\\\\\na_{31} & a_{32}\n\\end{bmatrix}+\n\\begin{bmatrix}\nb_{11} & b_{12}\\\\\nb_{21} & b_{22}\\\\\nb_{31} & b_{32}\n\\end{bmatrix}\\\\ &=\n\\begin{bmatrix}\na_{11}+b_{11} & a_{12}+b_{12}\\\\\na_{21}+b_{21} & a_{22}+b_{22}\\\\\na_{31}+b_{31} & a_{32}+b_{32}\n\\end{bmatrix}\n\\end{aligned}\n$$\n\n## Subtracting Matrices\n\nSubtracting matrices works the same way.\n\n$$\n\\begin{aligned}\\mathbf{A}-\\mathbf{B}&=\n\\begin{bmatrix}\na_{11} & a_{12}\\\\\na_{21} & a_{22}\\\\\na_{31} & a_{32}\n\\end{bmatrix}-\n\\begin{bmatrix}\nb_{11} & b_{12}\\\\\nb_{21} & b_{22}\\\\\nb_{31} & b_{32}\n\\end{bmatrix}\\\\ &=\n\\begin{bmatrix}\na_{11}-b_{11} & a_{12}-b_{12}\\\\\na_{21}-b_{21} & a_{22}-b_{22}\\\\\na_{31}-b_{31} & a_{32}-b_{32}\n\\end{bmatrix}\n\\end{aligned}\n$$\n\n### Adding and Subtracting Matrices in R\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:6,nrow = 2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n\n```{.r .cell-code}\nB <- matrix(seq(10,60,10),nrow = 2)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   10   30   50\n[2,]   20   40   60\n```\n\n\n:::\n\n```{.r .cell-code}\nAPlusB <- A + B\nAPlusB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   11   33   55\n[2,]   22   44   66\n```\n\n\n:::\n\n```{.r .cell-code}\nAMinusB <- A - B\nAMinusB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   -9  -27  -45\n[2,]  -18  -36  -54\n```\n\n\n:::\n:::\n\n\n\n\n\n## Scalar-Matrix Multiplication\n\nA *scalar* is a single number, not in a matrix. You can multiply a scalar by a matrix like so:\n\n$$k\\mathbf{A}=\nk\\begin{bmatrix}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\n\\end{bmatrix}=\n\\begin{bmatrix}\nka_{11} & ka_{12} & ka_{13}\\\\\nka_{21} & ka_{22} & ka_{23}\n\\end{bmatrix}$$\n\n### Scalar-Matrix Multiplication in R\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nk <- 10\nA <- matrix(1:6,nrow = 2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n\n```{.r .cell-code}\nkA <- k * A\nkA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   10   30   50\n[2,]   20   40   60\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nCreate a scalar *k* equal to 5.\n\nCreate a matrix **A** equal to \n\n$$\n\\mathbf{A} = \\begin{bmatrix}\n1,0\\\\\n3,5\n\\end{bmatrix}\n$$\n\nCalculate $k\\mathbf{A}$:\n\n```{webr-r}\n#| label: ex-scalarmatrix\nk <- _\nA <- _\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nk <- 5\nA <- matrix(c(1,3,0,5), nrow = 2)\nk * A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5    0\n[2,]   15   25\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n:::\n\n\n## Matrix Multiplication\n\nMatrix multiplication is considerably more complex than matrix addition and subtraction. It took me an embarrassingly long time for me to wrap my head around it. I will state things in the abstract first, but it is hard to see what is going on until you see a concrete example.\n\nIn order for matrices to be compatible for multiplication, the number of columns of the left matrix must be the same as the number of rows of the right matrix. The product of **A **and **B** will have the the same number of rows as **A** and the same number of columns as **B**.\n\nImagine that matrix **A** has *n* rows and *m* columns. Matrix **B** has *m* rows and *p* columns. When **A** and **B** are multiplied, the resulting product is matrix **C** with *n* rows and *p* columns.\n\n\n\n$$\n\\mathbf{A}_{n\\times m} \\mathbf{B}_{m\\times p} = \\mathbf{C}_{n\\times p}\n$$\n\nElement $c_{ij}$ of $\\mathbf{C}$ is the dot-product of row $i$ of $\\mathbf{A}$ and column $j$ of $\\mathbf{B}$. That is,\n\n$$c_{ij}=\\mathbf{A}_{i\\bullet}\\mathbf{B}_{\\bullet j}$$\n\n[This schematic](http://commons.wikimedia.org/wiki/File:Matrix_multiplication_diagram.svg) gives a nice visual summary:\n\n![Matrix Multiplication](http://upload.wikimedia.org/wikipedia/commons/1/11/Matrix_multiplication_diagram.svg){}\n\n### Matrix Multiplication Example\n\n$$\\mathbf{A}=\\begin{bmatrix}\n\\color{FireBrick}a&\\color{FireBrick}b&\\color{FireBrick}c\\\\\n\\color{RoyalBlue}e&\\color{RoyalBlue}d&\\color{RoyalBlue}f\n\\end{bmatrix}$$\n\n$$\\mathbf{B}=\\begin{bmatrix}\n\\color{green}g&\\color{DarkOrchid}h\\\\\n\\color{green}i&\\color{DarkOrchid}j\\\\\n\\color{green}k&\\color{DarkOrchid}l\n\\end{bmatrix}$$\n\n$$\\mathbf{AB}=\\begin{bmatrix}\n\\color{FireBrick}a\\color{Green}g+\\color{FireBrick}b\\color{green}i+\\color{FireBrick}c\\color{green}k&\\color{FireBrick}a\\color{DarkOrchid}h+\\color{FireBrick}b\\color{DarkOrchid}j+\\color{FireBrick}c\\color{DarkOrchid}l\\\\\n\\color{RoyalBlue}e\\color{green}g+\\color{RoyalBlue}d\\color{green}i+\\color{RoyalBlue}f\\color{green}k&\\color{RoyalBlue}e\\color{DarkOrchid}h+\\color{RoyalBlue}d\\color{DarkOrchid}j+\\color{RoyalBlue}f\\color{DarkOrchid}l\n\\end{bmatrix}$$\n\n\nUsing specific numbers:\n\n$$\\mathbf{A}=\\begin{bmatrix}\n\\color{FireBrick}1&\\color{FireBrick}2&\\color{FireBrick}3\\\\\n\\color{RoyalBlue}4&\\color{RoyalBlue}5&\\color{RoyalBlue}6\n\\end{bmatrix}$$\n\n$$\\mathbf{B}=\\begin{bmatrix}\n\\color{green}{10}&\\color{DarkOrchid}{40}\\\\\n\\color{green}{20}&\\color{DarkOrchid}{50}\\\\\n\\color{green}{30}&\\color{DarkOrchid}{60}\n\\end{bmatrix}$$\n\n$$\n\\begin{align}\n\\mathbf{AB}&=\n\\begin{bmatrix}\n\\color{FireBrick}1\\cdot\\color{green}{10}+\\color{FireBrick}2\\cdot\\color{green}{20}+\\color{FireBrick}3\\cdot\\color{green}{30}&\\color{FireBrick}1\\cdot\\color{DarkOrchid}{40}+\\color{FireBrick}2\\cdot\\color{DarkOrchid}{50}+\\color{FireBrick}3\\cdot\\color{DarkOrchid}{60}\\\\\n\\color{RoyalBlue}4\\cdot\\color{green}{10}+\\color{RoyalBlue}5\\cdot\\color{green}{20}+\\color{RoyalBlue}6\\cdot\\color{green}{30}&\\color{RoyalBlue}4\\cdot\\color{DarkOrchid}{40}+\\color{RoyalBlue}5\\cdot\\color{DarkOrchid}{50}+\\color{RoyalBlue}6\\cdot\\color{DarkOrchid}{60}\n\\end{bmatrix}\\\\[1ex]\n&=\\begin{bmatrix}\n140&320\\\\\n320&770\n\\end{bmatrix}\n\\end{align}\n$$\n\n\n### Matrix Multiplication in R\n\nThe `%*%` operator multiplies matrices (and the inner products of vectors).\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:6,nrow = 2,byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n\n```{.r .cell-code}\nB <- matrix(seq(10,60,10),nrow = 3)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]   10   40\n[2,]   20   50\n[3,]   30   60\n```\n\n\n:::\n\n```{.r .cell-code}\nC <- A %*% B\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]  140  320\n[2,]  320  770\n```\n\n\n:::\n:::\n\n\n\n\n\n\n# Elementwise Matrix Multiplication\n\nElementwise matrix multiplication is when we simply multiply corresponding elements of identically-sized matrices. This is sometimes called the *Hadamard product*.\n\n$$\\begin{aligned}A\\circ B&=\\begin{bmatrix} a_{11} & a_{12} & a_{13}\\\\ \na_{21} & a_{22} & a_{23} \n\\end{bmatrix} \\circ \n\\begin{bmatrix} \nb_{11} & b_{12} & b_{13}\\\\ \nb_{21} & b_{22} & b_{23}\n\\end{bmatrix}\\\\ \n&= \\begin{bmatrix} \na_{11}\\, b_{11} & a_{12}\\, b_{12} & a_{13}\\, b_{13}\\\\ \na_{21}\\, b_{21} & a_{22}\\, b_{22} & a_{23}\\, b_{23}\n\\end{bmatrix}\\end{aligned}$$\n\nIn R, elementwise multiplication is quite easy.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nC <- A * B\n```\n:::\n\n\n\n\n\nElementwise division works the same way.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n:::\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nSuppose we have threse three matrices:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n:::\n\n\n\n\n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{A} &=\\begin{bmatrix}\n15 & 9 & 6 & 19\\\\\n20 & 11 & 20 & 18\\\\\n15 & 3 & 8 & 5\n\\end{bmatrix}\\\\\n\\mathbf{B} &=\\begin{bmatrix}\n17 & 14 & 1 & 19\\\\\n11 & 2 & 12 & 14\\\\\n5 & 16 & 1 & 20\n\\end{bmatrix}\\\\\n\\mathbf{C} &=\\begin{bmatrix}\n5 & 16 & 20\\\\\n9 & 9 & 12\\\\\n15 & 5 & 8\\\\\n12 & 8 & 17\n\\end{bmatrix}\n\\end{aligned}\n$$\n\n1. $\\mathbf{A+B}=$ \n\n```{webr-r}\n#| label: ex-matrixaddAB\nA <- matrix(c(\n  15,9,6,19, \n\t20,11,20,18, \n\t15,3,8,5), \n  nrow = 3, byrow = TRUE)\nB <- matrix(c(\n  17,14,1,19, \n\t11,2,12,14, \n\t5,16,1,20), \n  nrow = 3, byrow = TRUE)\nC <- matrix(c(\n  5,16,20, \n\t9,9,12, \n\t15,5,8, \n\t12,8,17), nrow = 4, byrow = TRUE)\n\n# Add A and B\n_ + _\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA + B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   32   23    7   38\n[2,]   31   13   32   32\n[3,]   20   19    9   25\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n2. $\\mathbf{A-B}=$\n\n```{webr-r}\n#| label: ex-matrixsubractAB\n_ - _\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA - B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   -2   -5    5    0\n[2,]    9    9    8    4\n[3,]   10  -13    7  -15\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n3. $\\mathbf{A\\circ B}=$\n\n```{webr-r}\n#| label: ex-matrixhadamardAB\nA _ B\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA * B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]  255  126    6  361\n[2,]  220   22  240  252\n[3,]   75   48    8  100\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n4. $\\mathbf{AC}=$\n\n```{webr-r}\n#| label: ex-matrixmultAB\nA _ B\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA %*% C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]  474  503  779\n[2,]  715  663  998\n[3,]  282  347  485\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n:::\n\n## Identity Elements\n\nThe *identity element* for a binary operation is the value that when combined with something leaves it unchanged. For example, the additive identity is 0.\n\n$$X+0=X$$\n\nThe number 0 is also the identity element for subtraction.\n\n$$X-0=X$$\n\nThe multiplicative identity is 1.\n\n$$X \\times 1 = X$$\n\nThe number 1 is also the identity element for division and exponentiation.\n\n$$X \\div 1=X$$\n\n$$X^1=X$$\n\n### Identity Matrix\n\nFor matrix multiplication with square matrices, the identity element is called the *identity matrix*, $\\mathbf{I}$. \n\n$$\\mathbf{AI}=\\mathbf{A}$$\n\nThe identity matrix is a diagonal matrix with ones on the diagonal. For example, a $2 \\times 2$ identity matrix looks like this:\n\n$$\\mathbf{I}_2=\\begin{bmatrix}\n1 & 0\\\\\n0 & 1 \n\\end{bmatrix}$$\n\nA size-3 identity matrix looks like this:\n\n$$\\mathbf{I}_3=\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1 \n\\end{bmatrix}$$\n\nIt is usually not necessary to use a subscript because the size of the identity matrix is usually assumed to be the same as that of the matrix it is multiplied by.\n\nThus, although it is true that $\\mathbf{AI}=\\mathbf{A}$ and $\\mathbf{IA}=\\mathbf{A}$, it is possible that the $\\mathbf{I}$ is of different sizes in these equations, depending on the dimensions of $\\mathbf{A}$.\n\nIf $\\mathbf{A}$ has $m$ rows and $n$ columns, in $\\mathbf{AI}$, it is assumed that $\\mathbf{I}$ is of size $n$ so that it is right-compatible with $\\mathbf{A}$. In $\\mathbf{IA}$, it is assumed that $\\mathbf{I}$ is of size $m$ so that it is left-compatible with $\\mathbf{A}$. \n\n\n### The Identity Matrix in R\n\nTo create an identity matrix, use the `diag` function with a single integer as its argument. For example `diag(6)` produces a 6 by 6 identity matrix.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\ndiag(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    0    0    0    0    0\n[2,]    0    1    0    0    0    0\n[3,]    0    0    1    0    0    0\n[4,]    0    0    0    1    0    0\n[5,]    0    0    0    0    1    0\n[6,]    0    0    0    0    0    1\n```\n\n\n:::\n:::\n\n\n\n\n\n## Multiplicative Inverse\n\n$X$ multiplied by its *multiplicative inverse* yields the multiplicative identity, 1. The multiplicative inverse is also known as the *reciprocal*.\n\n$$X\\times \\frac{1}{X}=1$$\n\nAnother way to write the reciprocal is to give it an exponent of $-1$.\n\n$$X^{-1}=\\frac{1}{X}$$\n\n## Matrix Inverse\n\nOnly square matrices have multiplicative inverses. Multiplying square matrix $\\mathbf{A}$ by its inverse $(\\mathbf{A}^{-1})$ produces the identity matrix. \n\n$$\\mathbf{A}\\mathbf{A}^{-1}=\\mathbf{I}$$\n\nThe inverse matrix produces the identity matrix whether it is pre-multiplied or post-multiplied.\n\n$$\\mathbf{A}\\mathbf{A}^{-1}=\\mathbf{A}^{-1}\\mathbf{A}=\\mathbf{I}$$\n\nThe calculation of an inverse is [quite complex](http://en.wikipedia.org/wiki/Invertible_matrix#Methods_of_matrix_inversion) and is best left to computers.\n\nAlthough only square matrics can have inverses, not all square matrices have inverses. The procedures for calculating the inverse of a matrix sometimes attempt to divide by 0, which is not possible. Because zero cannot be inverted (i.e., $\\frac{1}{0}$ is undefined), any matrix that attempts division by 0 during the inversion process cannot be inverted.\n\nFor example, this matrix of ones has no inverse.\n\n$$\\begin{bmatrix}\n1 & 1\\\\\n1 & 1 \n\\end{bmatrix}$$\n\nThere is no matrix we can multiply it by to produce the identity matrix. In the algorithm for calculating the inverse, division by 0 occurs, and the whole process comes to a halt. A matrix that cannot be inverted is called a *singular matrix*. \n\n[[Collinear]{.defword} means that at least one of the variables can be perfectly predicted from the other variables.]{.defword .column-margin}\n\nThe covariance matrix of [collinear]{.defword} variables is singular. In multiple regression, we use the inverse of the covariance matrix of the predictor variables to calculate the regression matrix. If the predictor variables are collinear, the regression coefficients cannot be calculated. For example, if $Z=X+Y$, we cannot use $X$, $Y$, and $Z$ together as predictors in a multiple regression equation. $Z$ is perfectly predicted from $X$ and $Y$. In the calculation of the regression coefficients, division by 0 will be attempted, and the calculation can proceed no further. \n\nIf use to bother me that that collinear variables could not be used together as predictors. However, thinking a little further, revealed why it is impossible. The definition of a regression coefficient is the independent effect of a variable after holding the other predictors constant. If a variable is perfectly predicted by the other variables, that variable cannot have an independent effect. Controlling for the other predictor, the variable no longer varies. It become a constant. Contants have no effect.\n\nWhile regression with perfectly collinear predictors is impossible, regression with almost perfectly collinear predictors can produce strange and unstable results. For example, if we round $Z$, the rounding error makes $Z$ nearly collinear with $X$ and $Y$ but not quite perfectly collinear with them. In this case, the regression will run but might give misleading results that might differ dramatically depending on how finely rounded $Z$ is.\n\n### Calculating Inverses in R\n\nYou would think that the inverse function in R would be called \"inverse\" or \"inv\" or something like that. Unintuitively, the inverse function in R is `solve`. The reason for this is that `solve` covers a wider array of problems than just the inverse. To see how, imagine that we have two matrices of known constants $\\mathbf{A}_{m\\times m}$ and $\\mathbf{B}_{m\\times n}$. We also have a matrix of unknowns $\\mathbf{X}_{m\\times n}$. How do we solve this equation?\n\n$$\\mathbf{AX}=\\mathbf{B}$$\n\nWe can pre-multiply both sides of the equation by the inverse of $\\mathbf{A}$. \n\n$$\\begin{aligned}\\mathbf{AX}&=\\mathbf{B}\\\\\n\\mathbf{A}^{-1}\\mathbf{AX}&=\\mathbf{A}^{-1}\\mathbf{B}\\\\\n\\mathbf{IX}&=\\mathbf{A}^{-1}\\mathbf{B}\\\\\n\\mathbf{X}&=\\mathbf{A}^{-1}\\mathbf{B}\\end{aligned}$$\n\nYou may have encountered this kind of problem in an algebra class when you used matrices to solve systems of linear equations. For example, these equations:\n\n$$\\begin{aligned}\n2x -9y -2z &= 5\\\\\n-2x + 5y + 3z &= 3\\\\\n2x + 4y - 3z &= 12\n\\end{aligned}$$\n\ncan be rewritten as matrices\n\n$$\\begin{aligned}\\mathbf{AX}&=\\mathbf{B}\\\\\n\\begin{bmatrix}\n\\phantom{-}2 & -9 & -2\\\\\n-2 & \\phantom{-}5 & \\phantom{-}3\\\\\n\\phantom{-}2 & \\phantom{-}4 & -3\n\\end{bmatrix}\n\\begin{bmatrix}\nx  \\\\\ny \\\\\nz \n\\end{bmatrix}&=\n\\begin{bmatrix}\n5  \\\\\n3 \\\\\n12 \n\\end{bmatrix}\n\\end{aligned}$$\n\n\nIn R, problems of this sort are solved like so:\n\n`X -> solve(A,B)`\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(c(2, -9, -2,\n             -2,  5,  3,\n              2,  4, -3),\n            nrow = 3,byrow = TRUE)\nB <- matrix(c(5,3,-12),ncol = 1)\nX <- solve(A,B)\nX\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    2\n[2,]   -1\n[3,]    4\n```\n\n\n:::\n:::\n\n\n\n\n\nIf $\\mathbf{B}$ is unspecified in the `solve` function, it is assumed that it is the identity matrix and therefore will return the inverse of $\\mathbf{A}$. That is, if $\\mathbf{B=I}$, then\n\n$$\\begin{aligned}\n\\mathbf{AX}&=\\mathbf{B}\\\\\n\\mathbf{AX}&=\\mathbf{I}\\\\\n\\mathbf{A^{-1}AX}&=\\mathbf{A^{-1}I}\\\\\n\\mathbf{IX}&=\\mathbf{A^{-1}I}\\\\\n\\mathbf{X}&=\\mathbf{A^{-1}}\\\\\n\\end{aligned}$$\n\nThus, `solve(A)` is $\\mathbf{A}^{-1}$\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(c(1,0.5,0.5,1),nrow = 2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]  1.0  0.5\n[2,]  0.5  1.0\n```\n\n\n:::\n\n```{.r .cell-code}\nAinverse <- solve(A)\nAinverse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]\n[1,]  1.3333333 -0.6666667\n[2,] -0.6666667  1.3333333\n```\n\n\n:::\n\n```{.r .cell-code}\nA %*% Ainverse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n\n\n:::\n:::\n\n\n\n\n\n:::{.callout-note title=\"You Try\"}\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n:::\n\n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{A} &= \\begin{bmatrix}\n17 & 14 & 1 & 19\\\\\n11 & 2 & 12 & 14\\\\\n5 & 16 & 1 & 20\n\\end{bmatrix}\\\\[1ex]\n\\mathbf{B} &= \\begin{bmatrix}\n5 & 16 & 20\\\\\n9 & 9 & 12\\\\\n15 & 5 & 8\\\\\n12 & 8 & 17\n\\end{bmatrix}\\\\[1ex]\n\\mathbf{C} &= \\begin{bmatrix}\n5 & 16 & 20\\\\\n9 & 9 & 12\\\\\n15 & 5 & 8\\\\\n12 & 8 & 17\n\\end{bmatrix}\n\\end{aligned}\n$$\n\n1. Make a 3 $\\times$ 3 identity matrix.\n\n\n```{webr-r}\n#| label: ex-identity33\n\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\ndiag(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n2. $(\\mathbf{AB})^{-1}=$\n\n```{webr-r}\n#| label: ex-inverseBC\n\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nsolve(A %*% B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             [,1]        [,2]        [,3]\n[1,] -0.004573830  0.01403053 -0.00667532\n[2,]  0.011859448  0.03171994 -0.04419406\n[3,] -0.004178158 -0.02857500  0.03284660\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n3. $\\mathbf{AB(AB)}^{-1}=$\n\n```{webr-r}\n#| label: ex-identityBC\n\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\n(A %*% B) %*% solve(A %*% B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             [,1] [,2]          [,3]\n[1,] 1.000000e+00    0  0.000000e+00\n[2,] 4.440892e-16    1 -7.105427e-15\n[3,] 0.000000e+00    0  1.000000e+00\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n4. $\\mathbf{(C'C)^{-1}}=$\n\n\n```{webr-r}\n#| label: ex-inverseCtranspose\n\n```\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nsolve(t(C) %*% C)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             [,1]        [,2]        [,3]\n[1,]  0.008075633  0.01097719 -0.01218111\n[2,]  0.010977186  0.06675299 -0.05145894\n[3,] -0.012181111 -0.05145894  0.04298947\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n:::\n\n## Creating Sums with Matrices\n\nA non-bolded $1$ is just the number one.\n\nA bolded $\\mathbf{1}$ is a column vector of ones. For example,\n\n$$\n\\mathbf{1}_1=\\begin{bmatrix}\n1\n\\end{bmatrix}\\\\\n\\mathbf{1}_2=\\begin{bmatrix}\n1\\\\ 1\n\\end{bmatrix}\\\\\n\\mathbf{1}_3=\\begin{bmatrix}\n1\\\\ 1\\\\ 1\n\\end{bmatrix}\\\\\n\\vdots\\\\\n\\mathbf{1}_n=\\begin{bmatrix}\n1\\\\ 1\\\\ 1\\\\ \\vdots \\\\ 1\n\\end{bmatrix}\n$$\n\nLike the identity matrix, the length of $\\mathbf{1}$ is usually inferred from context.\n\nThe one vector is used to create sums. Post multiplying a matrix by $\\mathbf{1}$ creates a column vector of row sums.\n\nSuppose that \n\n$$\n\\mathbf{X}=\n\\begin{bmatrix}\n1 & 2\\\\\n3 & 4\n\\end{bmatrix}\n$$\n\n\n$$\n\\mathbf{X1}=\\begin{bmatrix}\n1 & 2\\\\\n3 & 4\n\\end{bmatrix}\n\\begin{bmatrix}\n1\\\\ 1\n\\end{bmatrix}\n=\\begin{bmatrix}\n3\\\\ \n7\n\\end{bmatrix}\n$$\n\nPre-multiplying by a transposed one matrix creates a row vector of column totals.\n\n$$\n\\mathbf{1'X}=\n\\begin{bmatrix}\n1& 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 2\\\\\n3 & 4\n\\end{bmatrix}\n=\\begin{bmatrix}\n4&6\n\\end{bmatrix}\n$$\n\nMaking a \"one sandwich\" creates the sum of the entire matrix.\n\n$$\n\\mathbf{1'X1}=\n\\begin{bmatrix}\n1& 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 2\\\\\n3 & 4\n\\end{bmatrix}\n\\begin{bmatrix}\n1\\\\ 1\n\\end{bmatrix}\n=\\begin{bmatrix}\n10\n\\end{bmatrix}\n$$\n\nTo create a $\\mathbf{1}$ vector that is compatible with the matrix it post-multiplies, use the `ncol` function inside the `rep` function:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:20,nrow = 4)\nOnes <- matrix(1, nrow = ncol(A)) \nA %*% Ones\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]   45\n[2,]   50\n[3,]   55\n[4,]   60\n```\n\n\n:::\n:::\n\n\n\n\n\nUse the `nrow` function to make a $\\mathbf{1}$ vector that is compatible with the matrix it pre-multiplies:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nOnes <- matrix(1, nrow = nrow(A))\nt(Ones) %*% A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   10   26   42   58   74\n```\n\n\n:::\n:::\n\n\n\n\n\nOf course, creating $\\mathbf{1}$ vectors like this can be tedious. Base R has convenient functions to calculate row sums, column sums, and total sums. \n\n\n`rowSums(A)` will add the rows of $\\mathbf{A}$:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nrowSums(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 45 50 55 60\n```\n\n\n:::\n:::\n\n\n\n\n\n`colSums(A)` with give the column totals of $\\mathbf{A}$:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\ncolSums(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 26 42 58 74\n```\n\n\n:::\n:::\n\n\n\n\n\n`sum(A)` will give the overall total of $\\mathbf{A}$:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nsum(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 210\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Eigenvectors and Eigenvalues\n\nConsider this equation related Square matrix $\\mathbf{A}$, vector $\\mathbf{v}$, and vector $\\mathbf{b}$:\n\n$$\\mathbf{Av=b}$$\n\nSquare matrix $\\mathbf{A}$ scales and rotates vector $\\mathbf{v}$ into vector $\\mathbf{b}$.\n\nIs there a non-zero vector $\\mathbf{v}$ that $\\mathbf{A}$ scales but does not rotate? If so, $\\mathbf{v}$ is an *eigenvector*. The value $\\lambda$ by which $\\mathbf{v}$ is scaled is the *eigenvalue*.\n\n$$\\mathbf{Av}=\\lambda\\mathbf{v}$$\n\nEvery eigenvector that exists for matrix $\\mathbf{A}$, is accompanied by an infinite number of parallel vectors of varying lengths that are also eigenvectors. Thus, we focus on the unit eigenvectors and their accompanying eigenvalues.\n\nEigenvectors and eigenvalues are extremely important concepts in a wide variety of applications in many disciplines. For us, they play a pivotal role in principal components analyses, factor analysis, and multivariate analyses such as MANOVA.\n\nEigenvectors (via principal components) help us rescale multivariate data into a smaller number of variables.\n\n### Eigenvectors and Eigenvalues in R\n\nThe eigenvectors of correlation matrix `A` below, represent the orientation vectors of the ellipsoid that contains the multivariate normal data. The eigenvalues of `A`\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n:::\n\n\n\n\n\n$$\\mathbf{A}=\\begin{bmatrix}\n1 & 0.7 & 0.5\\\\\n0.7 & 1 & 0.4\\\\\n0.5 & 0.4 & 1\n\\end{bmatrix}$$\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n:::\n\n\n\n\n\n$$\\boldsymbol{v}= \\begin{bmatrix}\n0.622574015164086 & -0.230658581674937 & 0.7477955698867\\\\\n0.59389705828702 & -0.482997848745687 & -0.643427822109879\\\\\n0.50959580041489 & 0.844695031835008 & -0.163714456883817\n\\end{bmatrix}$$\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n:::\n\n\n\n\n\n$$\n\\boldsymbol{\\lambda} = \\{2.08,0.63,0.29\\}\n$$\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" webgl='true'}\n\n:::\n\n\n\n\n\nFor symmetric matrices (e.g., correlation and covariance matrices), eigenvectors are orthogonal.\n\n\n:::{.callout-note title=\"You Try\"}\n\nExtract the eigenvalues and eigen vectors from correlation matrix `rho`.\n\n$$\nR=\\begin{bmatrix}\n1&.7\\\\\n.7&1\n\\end{bmatrix}\n$$\n\n```{webr-r}\n#| label: ex-eigenrho\nrho <- matrix(c(1,0.7,0.7,1),2)\n```\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nrho <- matrix(c(1,0.7,0.7,1),2)\neigenrho <- eigen(rho)\neigenrho\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\neigen() decomposition\n$values\n[1] 1.7 0.3\n\n$vectors\n          [,1]       [,2]\n[1,] 0.7071068 -0.7071068\n[2,] 0.7071068  0.7071068\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n:::\n\nEigenvectors have a magnitude of 1, but if they are scaled by the square root of the eigenvalues, they become the principal axes of the ellipse that contains the 68% of the data:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n::: {.cell-output-display}\n![The eigenvectors of rho scaled by the square roots of the eigenvectors are the principal axes of the ellipse that contains 68% of the data that have same correlation as rho.](matrices_files/figure-html/fig-eigenellipse-1.png){#fig-eigenellipse fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-eigenellipse\n\n```{.r .cell-code}\nd_eigen <- t(eigenrho$vectors %*% diag(sqrt(eigenrho$values))) %>% \n  `colnames<-`(c(\"x\", \"y\")) %>% \n  as.data.frame() \n\nd_points <- mvtnorm::rmvnorm(\n  n = 1000, \n  mean = c(x = 0, y = 0), \n  sigma = rho) %>% \n  as_tibble()\n\nellipse::ellipse(rho, t = 1) %>% \n  as.data.frame() %>% \n  ggplot(aes(x,y)) + \n  geom_point(data = d_points, \n             pch = 16, \n             size = .25, \n             color = \"gray30\") +\n  geom_polygon(alpha = .15, \n               fill = myfills[1], \n               aes(x = x * qnorm(.99),\n                   y = y * qnorm(.99))) +\n  geom_polygon(alpha = .15, \n               fill = myfills[1], \n               aes(x = x * qnorm(.95),\n                   y = y * qnorm(.95))) +\n  geom_polygon(alpha = .3, \n               fill = myfills[1]) +\n  geom_arrow_segment(\n    data = d_eigen,\n    aes(xend = x, \n        x = 0, \n        yend = y, \n        y = 0),\n    color = myfills[1],\n    arrow_head = arrow_head_deltoid()) +\n  coord_equal(xlim = c(-4,4),\n              ylim = c(-4,4)) +\n  scale_x_continuous(labels = \\(x) WJSmisc::prob_label(x, 1)) +\n  scale_y_continuous(labels = \\(x) WJSmisc::prob_label(x, 1))\n```\n\n\n:::\n:::\n",
    "supporting": [
      "matrices_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}