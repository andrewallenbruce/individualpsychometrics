{
  "hash": "7a7a16ae405f30d24f52d3c36c4a9c65",
  "result": {
    "markdown": "# Matrix Algebra in R\n\n\n\n\n\n\n[**Matrix algebra** refers to performing arithmetic operations and algebraic manipulations on numbers arranged in rectangular arrays.]{.defword .column-margin} [Matrix algebra]{.defword} sounds intimidating. If I could start somewhere else, I would, but psychometrics is too painful without matrix notation. Spending time to become familiar with matrix algebra makes a lot of otherwise difficult things easy. [For now, we will focus solely on numeric data, setting aside the possibility of creating vectors and matrices with non-numeric data such as logical (Boolean) values, nominal data, ordinal values, dates, or complex structures such as lists.]{.column-margin}\n\n\n\n\nDespite appearances, matrix algebra is not so hard. In my opinion, learning regular algebra is the hard part. If you made it through high school with a strong understanding of algebra, you will see that matrix algebra is mostly an extension of what you already know. Give it a try and see what happens. If learning matrix algebra  seems hard, firming up your foundational knowledge of regular algebra may be a better place to start.\n\nAlgebra uses symbols in formulas to represent numbers. You are probability familiar with using algebraic methods to solve for unknown values in equations. For example, in the equation below, there is only one possible value of $x$ that makes the equation true:\n\n$$\n\\begin{aligned}\nx-1&=0\\\\\nx-1+1&=0+1\\\\\nx&=1\\\\\n\\end{aligned}\n$$\n\nMatrix algebra allows us to use one symbol to represent more than one number at a time. So, instead of using one symbol to represent one number (e.g., $x=4$), a single symbol can represent a sequence of numbers:\n$$\\mathbf{x}=\\left(3,1,5,9\\right)$$\n\nOr just one symbol can represent a rectangular array of numbers:\n\n$$\n\\mathbf{A}=\\begin{bmatrix}\n5&7&9&2\\\\\n7&0&1&4\\\\\n3&2&8&0\n\\end{bmatrix}\n$$\n\n\nIn this way, we can perform the same operations (e.g., addition, multiplication, exponentiation) on many numbers at once (e.g., creating statistical models from many rows of data). The notation of matrix algebra often makes what would otherwise be large, messy, complex statistical formulas look simple, tidy, and compact.\n\n\n\nIn matrix algebra, we can arrange numbers as scalars (single values), vectors (sequences of values), and matrices (values in rectangular arrays).\n\n## Scalars\n\n[Scalars]{.defword}[A **scalar** is a single value.]{.defword .column-margin} are single numeric values. They are the [elements]{.defword}[A vector's **elements** are the individual numbers in a vector or matrix.]{.defword .column-margin} of vectors and matrices. Usually a scalar is represented as an italicized lowercase letter:\n\n$$\nx=9\n$$\n\n### Scalars in R\n\nTechnically, there are no scalars in R. Pretty much everything in R is a vector of one kind of another. This feature of R makes a lot of things nice and easy for data analysis, though it slows down certain kinds of computations. However, a vector with just one element in it is often treated like a scalar. If you want to make a \"scalar\" in R, you assign a value to a variable name like so:\n\n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" hash='matrix_algebra_cache/html/scalarassignment_c4244b50d1d5fdc52a087c128358861d'}\n\n```{.r .cell-code}\nx <- 1\n```\n:::\n\n\n:::{.column-margin}\n\nIn most situations, the `=` sign also functions as an assignment operator. It is easier to type than `<-`, so feel free to use it. \n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" hash='matrix_algebra_cache/html/scalarassignmentequal_0ce3eea8301833eb12043249ccb8d53f'}\n\n```{.r .cell-code}\nx = 1\n```\n:::\n\n\nI put spaces around most operator symbols (e.g., `+`, `-`, `*`, `/`, `^`, `=`) because it makes complex code easier to read. However, the spaces are optional, and you can use a more compact style if you wish:\n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" hash='matrix_algebra_cache/html/scalarassignmencompact_f7f4725c81ee401c290850252de670c9'}\n\n```{.r .cell-code}\nx=1\n```\n:::\n\n\n:::\n\nThe `<-` is called the *assignment operator*.  Instead of typing both characters, I use the {{< kbd Alt+- >}} keyboard shortcut (i.e., press {{< kbd Alt >}} and `-` at the same time time), which puts spaces around the assignment operator.\n\n\n::: {.callout-note title=\"You Try\"}\n\nCreate a variable `x` by assigning it a value of 5.\n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" solution='true' solutionsetter='true' hash='matrix_algebra_cache/html/solution-assignment_ee0621f5529c4cbe7ed3f063622b5462'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nx <- 5\n\n# If you prefer, the = assignment operator also works:\nx = 5\n\n# To display the value of x, just run it on its own line like so:\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n\n\n</details>\n:::\n\n\n:::\n\n## Vectors\n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" hash='matrix_algebra_cache/html/xy_90f31336c3ea2ae5f7db942547a3fb03'}\n\n:::\n\n\n[Vectors]{.defword}[A **vector** is an ordered sequence of values]{.defword .column-margin} are sequences of numbers. The notation for vectors is not always applied consistently, but typically vectors are bolded lowercase letters and the elements are listed in parentheses and separated by commas. A vector $\\mathbf{x}$ with elements 3 and 4 would be notated like so:\n\n$$\n\\mathbf{x}=\\left(3,4\\right)\n$$\n\n\nThe [vector length]{.defword}[A vector's **length** is the number of elements the vector contains.]{.defword .column-margin} refers to how many elements it has, not its magnitude. So a 2-element vector like $\\{x_1,x_2\\}$ has a length of 2.\n\nA sequence of indeterminate length $n$, would be notated like so\n\n$$\n\\mathbf{x}=\\left(x_1,x_2,\\ldots,x_n\\right)\n$$\n\n\n\nVectors in R are created many ways, but the most common way to join vector elements is with the `c` function (i.e. \"concatenate\" or link together in a chain).\n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" hash='matrix_algebra_cache/html/vector_eeac00cb529775491905abde9e9e6808'}\n\n```{.r .cell-code}\nx <- c(3, 5)\n```\n:::\n\n\n::: {.callout-note title=\"You Try\"}\n\nCreate a vector `x` with values 2 and 6.\n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" solution='true' solutionsetter='true' hash='matrix_algebra_cache/html/solution-vector_f4cb06c818de09c32d0bbd1c64781f3d'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nx <- c(2, 6)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 6\n```\n:::\n\n\n\n</details>\n:::\n\n\n:::\n\n\n::: {.cell .fig-column-margin .tbl-cap-location-margin layout-align=\"left\" opts.label='marginfigure' fig.cap.location='top' hash='matrix_algebra_cache/html/fig-vector_d6634a3d833f33712aa2f7db793ebd4f'}\n::: {.cell-output-display}\n![A vector of (4,3) moves 4 units to the right and 3 units up from the origin.](matrix_algebra_files/figure-html/fig-vector-1.png){#fig-vector fig-align='left' width=100%}\n:::\n:::\n\n\nA vector with two scalar elements can be thought of as an arrow in a coordinate plane, as in @fig-vector. The vector $\\left(4, 3\\right)$ is an arrow that displaces any point it is added to by 4 units to the right and 3 units up. \n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" button_r='true' figlabel='fig-vector' button_before_r='true' button_after='true' hash='matrix_algebra_cache/html/vectorCode_669202807ef1dc724e83a8741f375982'}\n<div class=\"wrap-collapsible\" style=\"margin-top: 1em\">\n<input id=\"collapsible-vectorCode\" class=\"toggle\" type=\"checkbox\">\n<label for=\"collapsible-vectorCode\" class=\"lbl-toggle\">R Code for @fig-vector</label><div class=\"collapsible-content\">\n<div class=\"content-inner\">\n\n```{.r .cell-code}\ntibble(x = c(0, x_plot), y = c(0, y_plot)) |>\n  ggplot(aes(x, y)) +\n  geom_line(\n    arrow = arrow(\n      angle = 15,\n      type = \"closed\",\n      length = unit(5, \"mm\")\n    ),\n    linewidth = 1,\n    linemitre = 2,\n    linejoin = \"mitre\",\n    color = myfills[1]\n  ) +\n  theme_classic(\n    base_family = bfont,\n    base_size = 20,\n    base_line_size = .5\n  ) +\n  theme(\n    axis.text = element_text(color = \"gray40\"),\n    axis.line = element_line(\n      linewidth = .5,\n      color = \"gray\",\n      arrow = arrow(\n        15,\n        type = \"closed\",\n        ends = \"both\",\n        length = unit(5, \"mm\")\n      )\n    ),\n    axis.ticks = element_line(color = \"gray\"),\n    axis.title.x = element_text(\n      angle = 0,\n      vjust = .5,\n      face = \"italic\",\n      color = \"gray40\"\n    ),\n    axis.title.y = element_text(\n      angle = 0,\n      vjust = .5,\n      face = \"italic\",\n      color = \"gray40\"\n    )\n  ) +\n  scale_x_continuous(name = \"y\", \n                     breaks = c(-5:-1, 1:5), \n                     labels = WJSmisc::signs_centered) +\n  scale_y_continuous(name = \"x\", \n                     breaks = c(-5:-1, 1:5), \n                     labels = signs) +\n  ggh4x::coord_axes_inside(\n    xlim = c(-5, 5),\n    ylim = c(-5, 5),\n    labels_inside = T,\n    ratio = 1\n  ) +\n  annotate(\n    \"richtext\",\n    x_plot,\n    y_plot,\n    label = paste0(\"**v** = (\", \n                   x_plot, \n                   \", \", \n                   y_plot, \n                   \")\"),\n    label.color = NA,\n    vjust = -.2,\n    hjust = 0.5,\n    fill = NA,\n    size = WJSmisc::ggtext_size(18),\n    label.r = unit(5, \"mm\"),\n    color = myfills[1]\n  ) +\n  annotate(\n    \"richtext\",\n    x_plot / 2,\n    y_plot / 2,\n    label = paste0(\"Magnitude of **v**: \\u2016**v**\\u2016 = \", \n                   round(sqrt(x_plot ^ 2 + y_plot ^ 2),2)),\n    label.color = NA,\n    angle = atan2(y_plot,x_plot) * 180 / pi,\n    vjust = 0,\n    hjust = 0.5,\n    fill = NA,\n    size = WJSmisc::ggtext_size(18),\n    label.r = unit(5, \"mm\"),\n    color = myfills[1]\n  )\n```\n\n</div></div></div>\n:::\n\n\n### Vector Addition \n\nTo add two vectors, add each element at the same position:\n\n$$\n\\begin{aligned}\n\\mathbf{x}&= \\left(x_1,x_2,\\ldots,x_n\\right)\\\\\n\\mathbf{y}&= \\left(y_1,y_2,\\ldots,y_n\\right)\\\\\n\\mathbf{x}+\\mathbf{y}&= \\left(x_1+y_1,x_2+y_2,\\ldots,x_n+y_n\\right)\\\\\n\\end{aligned}\n$$\n\nAs an example:\n\n$$\n\\begin{aligned}\n\\mathbf{x}&= \\left(1,2\\right)\\\\\n\\mathbf{y}&= \\left(3,4\\right)\\\\\n\\\\\n\\mathbf{x}+\\mathbf{y}&= \\left(1+3,2+4\\right)\\\\\n&= \\left(4,6\\right)\n\\end{aligned}\n$$\n\nVector subtraction works the same way as vector addition, subtracting each element at the same position:\n\n$$\n\\mathbf{x}-\\mathbf{y}= \\left(x_1-y_1,x_2-y_2,\\ldots,x_n-y_n\\right)\\\\\n$$\n\nAdding and subtracting two vectors is only defined when the vectors have the same number of elements. Thus, if $\\mathbf{x}= \\left(1,2\\right)$ and $\\mathbf{y}= \\left(3,2,1\\right)$, there is no defined way to add $\\mathbf{x}$ and $\\mathbf{y}$.\n\n\nIn R, adding and subtracting vectors is beautifully easy. Unlike many programming language, we do not need to create looping structures to add each element pair one at a time. We just define the vectors and add them:\n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" hash='matrix_algebra_cache/html/vectoraddition_022a9a4017dcbbd11acad311d2d4dfe9'}\n\n```{.r .cell-code}\nx <- c(1, 2)\ny <- c(3, 4)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 6\n```\n:::\n:::\n\n```{ojs}\nviewof fsab = \nInputs.form({\n  ax: Inputs.range([-1,1], {\n    format: (x) => x,\n    value: 1, \n    step: .01, \n    label:html`<em>a<sub>x</sub></em>`,\n    labelStyle: \"width: 50px\"\n  }),\n  ay: Inputs.range([-1,1], {value: 0, step: .01, label: html`<em>a<sub>y</sub></em>`}),\n  bx: Inputs.range([-1,1], {value:0, step: .01, label: html`<em>b<sub>x</sub></em>`}),\n  by: Inputs.range([-1,1], {value: 1, step: .01, label: html`<em>b<sub>y</sub></em>`})\n  })\nab=[{x0: 0, y0: 0, ax: fsab.ax, ay: fsab.ay, bx: fsab.bx, by: fsab.by, abx: fsab.ax + fsab.bx, aby: fsab.ay + fsab.by, theta: Math.atan2(fsab.ay + fsab.by, fsab.ax + fsab.bx), thetaa: Math.atan2(fsab.ay, fsab.ax), thetab: Math.atan2(fsab.by, fsab.bx), a: 'a', b: 'b', ab:'a + b', fill: '#ffffff', r: 200}]\n\n```\n\n```{ojs}\n//| label: fig-vector-addition\n//| fig-cap: \"Adding vectors a and b.\"\n//| cache: true\n//| fig-cap-location: margin\n\nPlot.plot({height: 600, width: 600,\nx: {domain: [-2, 2], grid: true, ticks: 9},\ny: {domain: [-2, 2], grid: true, ticks: 9},\nstyle: {\n    fontSize: 14, fontFamily: \"equity_text_a_tab\"\n  },\nmarks: [\n  Plot.ruleY([0]),\n  Plot.ruleX([0]),\n  Plot.arrow(ab, {x1: \"x0\", y1: \"y0\", x2: \"ax\", y2: \"ay\", stroke: \"#8B1A1A\", headAngle: 30, headLength: 10, fill: \"#8B1A1A\"}),\n  Plot.arrow(ab, {x1: \"ax\", y1: \"ay\", x2: \"abx\", y2: \"aby\", stroke: \"#27408B\", headAngle: 30, headLength: 10, fill: \"#27408B\", alpha: .5}),\n  Plot.arrow(ab, {x1: \"x0\", y1: \"y0\", x2: \"abx\", y2: \"aby\", stroke: \"#51315E\", headAngle: 30, headLength: 10, fill: \"#51315E\"}),\n  Plot.dot(ab, {x: (d) => d.ax/2, y: (d) => d.ay/2, fill: \"fill\", r: 7}),\n  Plot.dot(ab, {x: (d) => d.ax + d.bx/2, y: (d) => d.ay + d.by/2, fill: \"fill\", r: 7}),\n  Plot.dot(ab, {x: (d) => d.abx/2, y: (d) => d.aby/2, fill: \"fill\", r: 18}),\n  Plot.text(ab, {x: (d) => d.ax/2, y: (d) => d.ay / 2, text: 'a', rotate: (d) => Math.atan(Math.tan(d.thetaa)) * -180 / Math.PI, fill: '#8B1A1A'}),\n   Plot.text(ab, {x: (d) => d.ax + d.bx/2, y: (d) => d.ay + d.by / 2, text: 'b', rotate: (d) => Math.atan(Math.tan(d.thetab)) * -180 / Math.PI, fill: '#27408B'}),\n  Plot.text(ab, {x: (d) => d.abx/2, y: (d) => d.aby / 2, text: 'ab', rotate: (d) => Math.atan(Math.tan(d.theta)) * -180 / Math.PI, fill: '#51315E'})\n]})\n```\n\n\n\n\n### Scalar Multiplication of Vectors\n\n\nTo multiply a scalar by a vector, multiply every element in the vector by the scalar. If *a* is a scalar,\n\n\n$$a\\mathbf{x}=\\left(ax_1+ax_2+\\ldots+ax_n\\right)$$\n\n\nThey are called \"scalars\" because a scalar multiplied by a vector \"scales\" the vector by changing its magnitude.\n\n$$\\left\\|a\\mathbf{x}\\right\\|=a\\left\\|\\mathbf{x}\\right\\|$$\n\nYou can play with scalar multiplication with the web app in @fig-scalar. Set the *x* and *y* coodinates and \n\n\n```{ojs}\nviewof fs = \nInputs.form({\n  xi: Inputs.range([-1,1], {\n    format: (x) => x,\n    value: 1, \n    step: .01, \n    label: md`*x* `,\n    labelStyle: \"width: 50px\"\n  }),\n  yi: Inputs.range([-1,1], {value: 1, step: .01, vertical: true, label: md`*y*`}),\n  a: Inputs.range([-5,5], {value: 1, step: .01, label: md`*a* `, description: 'Scalar'})\n  })\nax = fs.xi * fs.a\nay = fs.yi * fs.a\ntheta=Math.atan2(ay,ax)\ndd=[{x: fs.xi, y: fs.yi, ax: ax, ay: ay, x0: 0, y0: 0, a: fs.a, theta: theta }]\n\nns = Inputs.range().classList[0]\n\nhtml`\n<style>\nform.${ns} {--input-width: 600px; --label-width: 15px;}\n.${ns}-input>input[type=number] {flex-shrink:6;}\n</style>\n`\n```\n\n```{ojs}\n//| label: fig-scalar\n//| fig-cap: \"Multiplying a vector by a scalar changes its magnitude.\"\n//| cache: true\n//| fig-cap-location: margin\n\nPlot.plot({height: 600, width: 600,\nx: {domain: [-5, 5], grid: true, ticks: 9},\ny: {domain: [-5, 5], grid: true, ticks: 9},\nstyle: {\n    fontSize: 14, fontFamily: \"equity_text_a_tab\"\n  },\nmarks: [\nPlot.ruleY([0]),\nPlot.ruleX([0]),\nPlot.arrow(dd, {x1: \"x0\", y1: \"y0\", x2: \"ax\", y2: \"ay\", stroke: \"#8B1A1A\", headAngle: 30, headLength: 10, fill: \"#8B1A1A\"}),\nPlot.arrow(dd, {x1: \"x0\", y1: \"y0\", x2: \"x\", y2: \"y\", stroke: \"#27408B\", headAngle: 30, headLength: 10, fill: \"#27408B\"}),\n  Plot.text(dd, {x: (d) => d.ax + .3 * Math.cos(d.theta), y: (d) => d.ay + .3 * Math.sin(d.theta), text: (d) => '('+(d.ax).toFixed(2)+', '+(d.ay).toFixed(2)+')'})\n]})\n```\n\n\n\nScalar division looks just like it does in regular algebra and can take on a variety of forms:\n\n$$\n\\mathbf{x}/a=\\frac{\\mathbf{x}}{a}=\\frac{1}{a}\\mathbf{x}=a^{-1}\\mathbf{x}=\\mathbf{x}\\div a\n$$\n\n\n\n\n\n### Vector Norms\n\nIf we visualize a vector as an arrow, we can ask how long the arrow is from end to end. The [norm]{.defword}[A vector's **norm** is the Euclidean distance of the vector's *n* elements to the origin in *n*-dimensional space.]{.defword .column-margin} is the vector's magnitude. Imagine the vector's *n* elements plotted as a single point in *n*-dimensional space. The norm is the distance of the point to the origin (i.e., a vector of *n* zeroes). The distance referred to here is technically the Euclidean distance, which is a generalization of the Pythagorean Theorem to more than 2 dimensions. To calculate it, take the square root of the sum of all squared values in the vector.\n\n:::{.column-margin}\n\nVector norms sometimes have notation that can be confused with absolute values: \n\n$$\\left|\\mathbf{x}\\right|$$\n\nThe notational confusion is not accidental. Scalar absolute values and vector norms both refer to magnitude. However, to avoid the ambiguity between vector norms and taking the absolute value of each element, I will use the double bar notation: \n\n$$\\left\\|\\mathbf{x}\\right\\|$$\n\nI tend to be fastidious about distinguishing between *vector length* (the number of elements in a vector) and vector *norms* (the vector's magnitude) because the concepts are easily confused. Further confusion is that the norm of a vector is not the same thing as a *normal vector*, which is a vector that is perpendicular to a surface (e.g., a plane, a sphere, or any other multidimensional object) at a given point. A normal vector has nothing to do with the normal distribution.\n\n:::\n\n\n$$\\left\\|\\mathbf{x}\\right\\|=\\sqrt{x_1^2+x_2^2+\\ldots+x_n^2}$$\n\n\n\n\n### Unit Vectors\n\nA vector norm is useful for create [unit vectors]{.defword}[A *unit vector* $\\mathbf{u}$ has a norm of 1: $\\left\\|\\mathbf{u}\\right\\|=1$]{.defword .column-margin}, which have the same direction as the original vector but have a norm (i.e, magnitude) of 1.\n\nSo a unit vector $\\mathbf{u}$ that has the same direction as vector $\\mathbf{x} = \\left(3,4\\right)$ is:\n\n$$\n\\begin{align*}\n\\mathbf{u}&=\\frac{\\mathbf{x}}{\\left\\|\\mathbf{x}\\right\\|}\\\\\n&=\\frac{\\left(3,4\\right)}{\\sqrt{3^2+4^2}}\\\\\n&=\\frac{\\left(3,4\\right)}{5}\\\\\n&=\\left(.6,.8\\right)\n\\end{align*}\n$$\n\nWe can verify that $\\mathbf{u}$ has a norm of 1:\n\n$$\n\\begin{align*}\n\\left\\|\\mathbf{u}\\right\\|&=\\left\\|\\left(.6,.8\\right)\\right\\|\\\\\n&=\\sqrt{.6^2+.8^2}\\\\\n&=1\n\\end{align*}\n$$\n\n\n\n\n\n### Vectors in R\n\n\n\nYou can make sequential integer sequences with the `:` operator or make any other kind of sequence with the the `seq` function:\n\n\n::: {.cell .tbl-cap-location-margin layout-align=\"center\" hash='matrix_algebra_cache/html/vectorseq_b05a3dad98600ceab3f11bab306dbe08'}\n\n```{.r .cell-code}\n# sequence from 1 to 5\n1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# Another way to make a sequence from 1 to 5\nseq(1,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# or just\nseq(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# from 5 to 1\nseq(5,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 4 3 2 1\n```\n:::\n\n```{.r .cell-code}\n# from 0 to 1 by .1 increments\nseq(0, 1, 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n```\n:::\n:::\n\n\n#### Arithmetic operations in R\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}