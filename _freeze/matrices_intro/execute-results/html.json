{
  "hash": "5b23fcabb1153f7fa63692037132bfea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Matrices\nsubtitle: Introduction\ntoc-title: Matrices--Introduction\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA matrix is a series of numbers arranged in rows and columns. We usually abbreviate matrices with a bolded uppercase letter:\n\n\n$$\n\\mathbf{A}_{j \\times k} =\n\\begin{bmatrix}\n  a_{1,1} & a_{1,2} & \\cdots & a_{1,k} \\\\\n  a_{2,1} & a_{2,2} & \\cdots & a_{2,k} \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  a_{j,1} & a_{j,2} & \\cdots & a_{j,k}\n\\end{bmatrix}\n$$\n\n\nFor example, \n\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n  1&2&3&4\\\\\n  5&6&7&8\\\\\n  9&10&11&12\n\\end{bmatrix}\n$$\n\nTo make a matrix in R, there are many possibilities. For the sake of simplicity, I will recommend using the `matrix` function with the `byrow` option set to `TRUE`. \n\nThe `matrix` function takes a vector and converts it to a matrix. By default, the `matrix` function assumes that the vector is a single column. For example,\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(1:4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nBy setting the `nrow` (number of rows) or `ncol` (number of columns), the matrix dimensions are set. For example,\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(1:4, ncol = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nNote that the default is to fill in the matrix by columns. If you want it to fill by rows, set the `byrow` option to `TRUE`.\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(1:4, ncol = 2, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nIn general, creating matrices by row makes the code and the matrix look similar:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(c(3, 5, \n         2, 3),\n       nrow = 2,\n       byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    3    5\n[2,]    2    3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nTo achieve the same matrix without the `byrow` option set to `TRUE` is possible, but the code will not be in the same order as the matrix:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmatrix(c(3, 2, \n         5, 3),\n       nrow = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    3    5\n[2,]    2    3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.callout-note title=\"You Try\"}\n\nMake vector `A` into a 2 by 2 matrix like so:\n\n$$\n\\mathbf{A}=\\begin{bmatrix}\n  2&3\\\\\n  5&7\n \\end{bmatrix}\n$$\n\n```{webr-r}\n#| label: ex-makeA\nA <- matrix(c(_,_,\n              _,_), \n            nrow = _, \n            byrow = _)\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\n# Using the matrix function setting byrow = TRUE\nA <- matrix(c(2, 3,\n              5, 7),\n            nrow = 2,\n            byrow = TRUE)\n```\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n\n## Appending Matrices\n\n$$\n\\color{RoyalBlue}{\\mathbf{A}}=\\begin{bmatrix}\n\\color{RoyalBlue}{1} & \\color{RoyalBlue}{2} & \\color{RoyalBlue}{3} & \\color{RoyalBlue}{4} \\\\ \n\\color{RoyalBlue}{5} & \\color{RoyalBlue}{6} & \\color{RoyalBlue}{7} & \\color{RoyalBlue}{8} \\\\ \n\\color{RoyalBlue}{9} & \\color{RoyalBlue}{10} & \\color{RoyalBlue}{11} & \\color{RoyalBlue}{12}\n\\end{bmatrix}, \\color{Firebrick}{\\mathbf{B}}=\\begin{bmatrix}\n\\color{Firebrick}{13} & \\color{Firebrick}{14} & \\color{Firebrick}{15} & \\color{Firebrick}{16} \\\\ \n\\color{Firebrick}{17} & \\color{Firebrick}{18} & \\color{Firebrick}{19} & \\color{Firebrick}{20}\n\\end{bmatrix}\n$$\n\nThe equation below means, \"Make a new matrix called C by appending B to the bottom of A.\"\n\n$$\n\\mathbf{C}=\\begin{bmatrix}\n\\color{RoyalBlue}{\\mathbf{A}} \\\\ \\color{FireBrick}{\\mathbf{B}} \n\\end{bmatrix}=\n\\begin{bmatrix}\n\\color{RoyalBlue}{1} & \\color{RoyalBlue}{2} & \\color{RoyalBlue}{3} & \\color{RoyalBlue}{4} \\\\ \n\\color{RoyalBlue}{5} & \\color{RoyalBlue}{6} & \\color{RoyalBlue}{7} & \\color{RoyalBlue}{8} \\\\ \n\\color{RoyalBlue}{9} & \\color{RoyalBlue}{10} & \\color{RoyalBlue}{11} & \\color{RoyalBlue}{12}\\\\\n\\color{Firebrick}{13} & \\color{Firebrick}{14} & \\color{Firebrick}{15} & \\color{Firebrick}{16} \\\\ \n\\color{Firebrick}{17} & \\color{Firebrick}{18} & \\color{Firebrick}{19} & \\color{Firebrick}{20}\n\\end{bmatrix}\n$$\n\nIn R, adding new rows to a matrix is done with the `rbind` function (Think \"row bind\"). To append rows, matrices must have the same number of columns to be compatible.\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\nB <- matrix(13:20, nrow = 2, byrow = TRUE)\nC <- rbind(A,B)\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n[5,]   17   18   19   20\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nThe `cbind` function (Think \"column bind\") works the same way but it appends columns to the right of a matrix. Matrices must have the same number of rows to be compatible.\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:4, nrow = 2)\nB <- matrix(5:8, nrow = 2)\nC <- cbind(A,B)\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.callout-note title=\"You Try\"}\n\nMake a 2 by 2 matrix `A`:\n\n$$\nA=\\begin{bmatrix}\n  11&13\\\\\n  17&19\n\\end{bmatrix}\n$$\n\nMake a 2 by 2 matrix `B`:\n\n$$\nB=\\begin{bmatrix}\n  11&13\\\\\n  17&19\n\\end{bmatrix}\n$$\n\n\nAppend `A` and `B` with `rbind` to make a 4 by 2 matrix like so:\n\n$$\n\\begin{bmatrix}\n  2&3\\\\\n  5&7\\\\\n  11&13\\\\\n  17&19\n\\end{bmatrix}\n$$\n\n\n```{webr-r}\n#| label: ex-rbinding\nA <- matrix(c(_,_,\n              _,_), \n            nrow = _, \n            byrow = _)\nB <- matrix(c(_,_,\n              _,_), \n            nrow = _, \n            byrow = _)\n\n# Now bind A and B by rows\nrbind(_,_)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA <- matrix(c(2, 5, 3, 7), nrow = 2)\nB <- matrix(c(11,17,13,19), nrow = 2)\nrbind(A, B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    3\n[2,]    5    7\n[3,]   11   13\n[4,]   17   19\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nNow use `cbind` to make a 2 by 4 matrix:\n\n$$\n\\begin{bmatrix}\n  2&3&11&13\\\\\n  5&7&17&19\n\\end{bmatrix}\n$$\n\n\n```{webr-r}\n#| label: ex-cbinding\n# Now bind A and B by columns\ncbind(_,_)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\ncbind(A, B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    3   11   13\n[2,]    5    7   17   19\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n\n\n## Selecting parts of a matrix \n\nOften we need to select smaller portions of a larger matrix. For example, suppose we have a 3 by 4 matrix **A**:\n\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n  1&2&3&4\\\\\n  5&6&7&8\\\\\n  9&10&11&12\n\\end{bmatrix}\n$$\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n### Select a single element of a matrix\n\nTo select a single element of a matrix, specify the row and column in brackets after the matrix. For example, the element $\\mathbf{A}_{3,2}$ (i.e., the 3^rd^ row and 2^nd^ column of $\\mathbf{A}$) is \n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[3,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.callout-note title=\"You Try\"}\n\nSelect the element in row 2, column 3\n\n```{webr-r}\n#| label: ex-select\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\nA[_,_]\n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[2,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n### Select a matrix row\n\nLeaving one of the slots in the bracket empty means that you want all of the elements in that row or column. \n\n$\\mathbf{A}_{1\\bullet}$ is the 1^st^ row of $\\mathbf{A}$.\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n### Select a matrix column\n\n$\\mathbf{A}_{\\bullet 3}$ is the 3^rd^ column of $\\mathbf{A}$.\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  7 11\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nBy default, whenever a single row, column, or element is returned from a matrix, R drops the row and column dimensions. If you wish to preserve the result in matrix form, set `drop` to `FALSE`:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[, 3, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    3\n[2,]    7\n[3,]   11\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nSelect column 1 of A.\n\n```{webr-r}\n#| label: ex-selectA1\nA[, _]\n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 9\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n\n\n### Select several columns or rows\n\nA vector of integers will select whichever rows or columns you wish. Here are the 2^nd^ and 3^rd^ rows:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[2:3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    5    6    7    8\n[2,]    9   10   11   12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nHere are the 1^st^ and 4^th^ columns:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[, c(1, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    5    8\n[3,]    9   12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nSelect columns 1 and 3 of A. \n\n```{webr-r}\n#| label: ex-matrixcols\nA\n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[, c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    5    7\n[3,]    9   11\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n\n### Selecting with Boolean vectors\n\nHere is the first two rows of $\\mathbf{A}$:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[c(TRUE,TRUE,FALSE),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nThis seems like a strange way to do this, but it is actually quite powerful. Any vector of `TRUE` and `FALSE` values can be used to select things. For example, select a column only if its first value is greater than 2:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create a vector that tests whether the \n# first row elements are greater than 2\ns <- A[1, ] > 2 \n# Select only the columns whose \n# first value is greater than 2\nA[, s] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    3    4\n[2,]    7    8\n[3,]   11   12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nUse a Boolean vector to select columns that begin with 2. The operator for \"is equal to\" is `==`.\n\n```{webr-r}\n#| label: ex-boolean\ns <- A[] == _ \nA[,s] \n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\ns <- A[1,] == 2 \n# When only one column or row is selected, R returns a vector\nA[,s]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  6 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# To force R to return a matrix, set drop = FALSE\nA[,s, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    2\n[2,]    6\n[3,]   10\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n\n### Selecting with name vectors\n\nSuppose matrix **A** represents the number of Olympic medals a country has won in different gymnastics events. We can give row and column names to a matrix like so:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nrownames(A) <- c(\"Gold\",\"Silver\",\"Bronze\")\ncolnames(A) <- c(\"Vault\",\"Uneven Bars\",\"Balance Beam\",\"Floor\")\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold       1           2            3     4\nSilver     5           6            7     8\nBronze     9          10           11    12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nNow we can select rows and columns by names. To select only the gold and bronze meal rows:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[c(\"Gold\",\"Bronze\"),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold       1           2            3     4\nBronze     9          10           11    12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nUse the column names to select the Uneven Bars column\n\n```{webr-r}\n#| label: ex-uneven\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\nrownames(A) <- c(\"Gold\",\"Silver\",\"Bronze\")\ncolnames(A) <- c(\"Vault\",\"Uneven Bars\",\"Balance Beam\",\"Floor\")\n# select the Uneven Bars column\nA[,_]\n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[,\"Uneven Bars\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Gold Silver Bronze \n     2      6     10 \n```\n\n\n:::\n\n```{.r .cell-code}\n# or to force R to return a matrix\nA[,\"Uneven Bars\", drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Uneven Bars\nGold             2\nSilver           6\nBronze          10\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nSelect the intersection of Silver and Floor\n\n```{webr-r}\n#| label: ex-silverfloor\nA\n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[\"Silver\", \"Floor\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# or\nA[\"Silver\", \"Floor\", drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Floor\nSilver     8\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n## Replace portions of a matrix\n\nAny portion of a matrix can be replaced with new values. For example, this will replace the first row with zeros:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[1, ] <- c(0, 0, 0, 0)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold       0           0            0     0\nSilver     5           6            7     8\nBronze     9          10           11    12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nThis can be done by column or row name as well\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA[\"Gold\", ] <- c(0, 0, 0, 0)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold       0           0            0     0\nSilver     5           6            7     8\nBronze     9          10           11    12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\nReplace the Vault column of $\\mathbf{A}$ with a vector of $(10,20,30)$\n\n```{webr-r}\n#| label: ex-replacevault\nA\n```\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA[, \"Vault\"] <- c(10, 20, 30)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Vault Uneven Bars Balance Beam Floor\nGold      10           0            0     0\nSilver    20           6            7     8\nBronze    30          10           11    12\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n## Transposing matrices\n\nTo [transpose]{.defword title=\"To *transpose* a matrix is to write its rows as columns and its columns as rows.\"} a matrix is to flip its rows into columns.\n\n$\\mathbf{A}'$ is matrix $\\mathbf{A}$ transposed.\n\nIf\n\n$$\\mathbf{A}=\\begin{bmatrix}\n1&2&3\\\\\n4&5&6\n\\end{bmatrix}$$\n\nThen \n\n$$\\mathbf{A}'=\\begin{bmatrix}\n1&4\\\\\n2&5\\\\\n3&6\n\\end{bmatrix}$$\n\n### Transposing in R\n\nIn R the `t` function transposes matrices.\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- matrix(1:6, nrow = 2, byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n\n```{.r .cell-code}\nA_prime <- t(A)\nA_prime\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n::: {#callout-note title=\"You Try\"}\n\n1. Make a 2 $\\times$ 5 matrix `A` of even numbers up to 20. \n2. Transpose `A`, assigning it to a variable called `A_prime`.\n3. Replace the last row (row 5) of `A_prime` with zeroes.\n\n```{webr-r}\n#| label: ex-even20transpose\nA <- matrix(seq(_,_,_), nrow = _)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nA <- matrix(seq(2, 20, 2), nrow = 2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    2    6   10   14   18\n[2,]    4    8   12   16   20\n```\n\n\n:::\n\n```{.r .cell-code}\nA_prime <- t(A)\nA_prime\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    4\n[2,]    6    8\n[3,]   10   12\n[4,]   14   16\n[5,]   18   20\n```\n\n\n:::\n\n```{.r .cell-code}\nA_prime[5, ] <- c(0, 0)\nA_prime\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    4\n[2,]    6    8\n[3,]   10   12\n[4,]   14   16\n[5,]    0    0\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\n\n\n\n\n\n\n\n\n:::\n\n\n\n## Square matrices\n\nIn a [square matrix]{.defword title=\"A **square matrix** has an equal number of rows and columns.\"}, the number of rows is equal to the number of columns. Some operations in matrix algebra require square matrices. To test whether a matrix is square, test whether the rows and columns of a matrix are equal:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n# A is a 3 by 4 matrix, so it is not square\nnrow(A) == ncol(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Symmetric matrices\n\nA **symmetric matrix** is a square matrix that is equal to its transpose.\n\n$$\\mathbf{A}=\\mathbf{A}'$$\n\nThis means that for all elements, $a_{ij}=a_{ji}$.\n\nHere is an example of a symmetric matrix:\n\n$$\\begin{bmatrix}\n\\color{green}a & \\color{Firebrick}b & \\color{RoyalBlue}c\\\\\n\\color{Firebrick}b & \\color{gold}d & \\color{DarkOrchid}e\\\\\n\\color{RoyalBlue}c & \\color{DarkOrchid}e & \\color{orange}f\n\\end{bmatrix}$$\n\nTo verify that a matrix is symmetric in R:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nisSymmetric(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\nCorrelation matrices and covariance matrices are always symmetric.\n\n## Diagonal matrices\n\n\n\nA [diagonal matrix]{.defword title=\"A **diagonal matrix** has non-zero elements only on the diagonal vector.\"} is a square matrix consisting of zeroes everywhere except the diagonal. For example,\n\n$$\n\\mathbf{A} = \\begin{bmatrix}\na & 0 & 0\\\\\n0 & b & 0\\\\\n0 & 0 & c\n\\end{bmatrix}\n$$\n\n### Creating diagonal matrices\n\nAs will be seen, the `diag` function does different things depending on the type of input it receives. If its input is a vector, it will create a diagonal matrix. That is, the `diag` function creates a diagonal matrix $\\mathbf{A}$ from a vector $\\vec{a}$ like so:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n# Make a vector\na <- 1:4\n# Make a diagonal matrix\nA <- diag(a)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    2    0    0\n[3,]    0    0    3    0\n[4,]    0    0    0    4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n### Extracting the diagonal vector from a matrix\n\nThe `diag` function extracts a diagonal vector $\\vec{a}$ from a matrix $\\mathbf{A}$.  \n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\ndiag(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n### Replacing the diagonal of a matrix\n\nThe `diag` function can also be used to replace a diagonal of a matrix:\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\ndiag(A) <- 5:8\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    5    0    0    0\n[2,]    0    6    0    0\n[3,]    0    0    7    0\n[4,]    0    0    0    8\n```\n\n\n:::\n:::\n",
    "supporting": [
      "matrices_intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}